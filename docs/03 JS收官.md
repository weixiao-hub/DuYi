---
outline: deep
---

### 知识的回顾-数据的表达1

- 声明式语言 html,css,sql
- 命令式语言 c,c++,c#,js,java,php,python
- javascript 是命令式编程语言，和其他命令式编程语言一样，他的本质是处理数据
- js 提供了三种方式来表达一个数据
- 变量
- 字面量: 直接书写的值为字面量， var a = 1, 1为字面量，var a = {} , {} 为字面量
- 表达式;

#### 标识符

- 程序中有些可以自行命名的地方，称为标识符
- 常见的标识符有：变量名，函数名，参数名
- js 标识符必须符合以下规则
    1. 不得以数字开头
    2. 允许数字，字母，下划线，$符号
    3. 不能和关键字冲突
    4. 建议使用驼峰命名法

#### 转义符

| 转义符 | 含义      |
|-----|---------|
| \\' | 普通英文单引号 |
| \\" | 普通英文双引号 |
| \r  | 回车      |
| \n  | 换行      |

- 小技巧： 常用 `\r\n` 标识换行

### 知识回顾-数据的表达2

- 数据类型

1. 原始类型：number、string、Boolean、null、undefined
2. 引用类型：对象（普通对象、数组、函数）

- 对象的原始写法
  对象的 `所有属性名都是字符串`，因此使用单引号或双引号包裹起来

````javascript
var obj = {
  'name': 'ddd',
  'age': 23,
  'address': {}
}
````

### 知识回顾-数据的表达3

- 数组，用于表达多个同种类的数据
- 它的本质就是一个对象

````javascript
[
  {
    name: 'xx',
    age: 223,
  }, {
    name: 'bb',
    age: 44
  }
]
````

### 知识回顾-数据的运算

#### 运算符

##### 算术运算符

1. 支持加减乘除,求余（%）
2. `+` 和 `-` 可以放到单个数据面前，表示正负
3. 算术运算的`表达式`一定返回数字，可以利用其特点做类型转换

##### 字符串拼接
---
当`+`的两端有一个是字符串时，不再进行算术运算，而变为字符串拼接

表达式一定返回string，可以利用其特点做类型转换
##### 赋值运算
---
涉及的运算符：`=` `+=` `*=` `/=` `-=` `%=` <br/>
其中, `a += b` , 等效于 `a = a + b`
:::tip
赋值表达式始终返回赋值结果，可以利用其特点完成连续赋值

```javascript
// 将3同时赋值给a,b;
// 解析 ： 1. 把（b=3）的运算结果赋值给a; 2. b =3 的运算结果为3
a = b = 3

```

:::
##### 比较运算
---
涉及的运算符： `==` `===` `!=` `!==` `>` `>=` `<` `<=`
:::tip
在实际开发中，请使用 `===` `!==`
比较运算符始终返回Boolean，可以利用其特点完成某些赋值

```javascript
let a = '男'
const isMale = a === '男';

```

:::
##### 逻辑运算
---
逻辑运算会涉及到布尔判断。<br/>
运算符 `!`:对后面的数据取反，表达式一定返回Boolean值 <br/>
运算符 `&&` 具有短路规则 <br/>
运算符 `||`,表达式返回最后一个判断的数据 具有短路规则
:::tip
实际开发中，可以利用短路规则简化代码

```javascript
const exp = xxx;
exp && console.log('aaa')

const n = exp || '';
```

:::
#### 布尔判断
---
所有需要判断真假的地方都会用到以下规则

| 数据                                        | 判定    |
|:------------------------------------------|-------|
| `false` `null` `undefined` `0` `NaN` `''` | false |
| 剩余所有数据                                    | true  |

#### 类型的隐式转换
---
每个运算符都有自己期望的数据，比如`*`期望两端都是数字，一旦数据不符合运算符的期望，
js就会对数据进行类型转换，把它转换为期望的值后进行运算。

值得注意的是，这种转换是临时的，不会对原数据造成影响

:::tip
在实际的开发中，可以利用隐式类型转换完成以下功能

```javascript
let n = +a; // 不管a是什么，都会被转换成数字，保存到n中
let s = a + ''; // 不管a是什么，都会被转换成字符串，保存到s中
let b = !!a; // 不管a是什么，都会被转换成boolean，保存到b中

```

:::

### 知识回顾-数据的流程

- 线性流程、分支流程、循环流程

### 知识回顾-流程的分割

#### 函数的作用

使用函数切割流程，不仅可以减少重复代码，还可以降低整体的复杂度

#### 函数的常见问题

##### 如何理解函数的参数、返回值、函数体

1. 参数: 表示完成流程所需要的必要信息
2. 返回值： 表示完成流程后产生的结果
3. 函数体： 表示具体的流程
4. **函数的参数、返回值只取决于函数的作用，与函数体无关**

##### 为什么有了函数后，程序反而变得复杂了？

1. 函数的核心作用，是为了让一段复杂的流程变得简单。如果在函数的帮助下，反而觉得流程变得复杂
   了，极有可能的原因是开发思想没有做相应的切割，导致思想负担过重。<br/>

**始终记住以下两点**

1. 定义函数时，只需要考虑这个函数如何实现即可，完全不需要考虑其他无关的东西。
2. 调用函数时，只需要考虑向其传递什么函数，如何使用它的返回结果，完全无需考虑函数的具体实现。
   <br>函数具有三要素：函数名，参数，返回值

##### 学习函数时不知道如何切割流程怎么办？

要完成一个函数声明，分为两步：

1. 设计函数<br/>
   设计函数就是如何切割流程，具体来说就是设计出函数的三要素，这一步是最难的（多学习优秀的框架）
2. 书写函数体<br>
   根据设计的三要素完成函数体，（多练）

### 核心概念-数据的存储和传递

#### 值和引用

```javascript
var a = 1;
var b = {
  n1: 1,
  n2: 2,
  addr: {
    city: '北京',
  }
}


```

:::tip
值类型：<br>
所有的原始类型，都是直接存储值 <br>
引用类型：<br>
在程序里开辟一块新内存空间,把该对象的地址赋值给变量b, 如果对象中的属性，其属性值为对象，重复该流程

| 内存空间 |    |
|:-----|----|
| n1   | 1  |
| n2   | 2  |
| addr | 地址 |

| 内存空间 |    |
|:-----|----|
| city | 北京 |

注意：给函数的形参直接赋值，对外部没有影响。 直接赋值： obj = xxx, 不是obj.a = xxx
:::

```javascript
// 删除对象中的属性
let obj = {a: 1, b: 2};
for (let key in obj) {
  if (obj[key] === 1) {
    delete obj[key]
  }
}

```

### 核心概念-数据的作用域

**1.js有两种作用域：全局作用域和函数作用域**

- 内部的作用域能访问外部，反之不行。访问时从内向外依次查找。
- 如果在内部的作用域中访问了外部，则会产生闭包
- 内部作用域能访问的外部，取决于函数定义的位置，和调用无关。

**2.作用域内定义的变量、函数声明会提升到作用域顶部**

### 核心概念-全局对象

1. 无论是浏览器环境还是node环境，都会提供一个全局对象
    - 浏览器环境：window
    - node：global

2. 全局对象有以下几个特点：

- 全局对象的属性可以被直接访问。
- 给未声明的变量赋值，实际上就是给全局对象赋值。（不要这么做）
- 所有的全局变量、全局函数都会附加到全局对象
  :::tip
  这被称为全局污染，又称为全局暴露，或简称污染、暴露
  如果要避免污染，需要使用立即执行函数改变其作用域
  立即执行函数又称为iife： immediately invoked Function Expression
  IIFE 通常用于强行改变作用域
  :::

```javascript
const init = function () {
  console.log('aaa')
};
init();
// 简化成立即执行函数：为了浏览器知道它不是一个函数声明，而是一个函数表达式，使用小括号包起来：
// 如果想要使用立即执行函数里面的变量，可以return出去，用一个变量test接收，这样在全局对象中只会附加该变量test

const test = (function () {
  console.log('aaa')
  let a = 'ccc';
  return a;
})();
```

### 核心概念-构造函数

1. js所有的对象，都是通过构造函数产生的

```javascript
// 语法糖
let obj = {
  a: 'aaa'
}
// 实际上
let obj = new Object(); // 创建一个空对象
obj.a = 'aaa'

let arr = [1, 2, 3];
let arr = new Array(1, 2, 3)

function fn(a, b) {
  return a + b
};
let fn = new Function('a', 'b', 'return a+b')
```

:::tip
new 构造函数:  创建一个对象，把 this绑定到该对象，返回该对象

```javascript
function Person() {
  //let this = {};
  // 这里是书写的代码
  // return this;
}
```

:::

### 核心概念- 原型

#### 原型要解决的问题

:::tip
![](assets/images/03%20JS收官/构造函数.png)
上图中,通过构造函数可以创建一个用户对象

这种做法有一个严重的缺陷，就是每一个对象中都有一个`sayHi`方法，对于每个用户而言，`sayHi`
方法代码是完全一样的，造成内存空间的浪费。没必要为每一个用户单独生成一个。

要解决这个问题，必须学习原型链
:::

#### 原型是如何解决的

![](assets/images/03%20JS收官/原型.png)

1. 原型 <br/>
   每个函数都会自动附带一个书写prototype,这个属性的值是一个普通对象，称为原型对象。
2. 实例 <br/
   instance,通过new 产生的对象称为实例。
   :::tip
   由于js中所有的对象都是通过new 产生的，所以，严格来说，js中的所有对象都可以称为实例
   :::
3. 隐式原型 <br/>
   每个实例上都有一个特殊的属性`__proto`,称为隐式原型，它指向构造函数的原型
4. 意义：<br/>
   :::tip
   **当访问实例成员时，先找自身，如果不存在，会自动的从隐式原型中寻找**

   这样就可以把那些公共的成员，放到函数的原型当中，可以被所有的实例共享
   ![](assets/images/03%20JS收官/共享.png)
   :::

### 核心概念- this

* 在全局代码中，this 指代全局对象 （在真是开发中，很少在全局代码中使用this）
* 在函数中使用this，它的指向取决于函数的调用方式

| 调用方式    | 示例            | 函数中的this指向  | 调用时机 |   参数形式  |  返回值    |
|:--------|---------------|-------------|------|-----|-----|
| 通过new调用 | new Fn()      | 新对象（实例）     |      |     |     |
| 直接调用    | fn();         | 全局对象        |      |     |     |
| 通过对象调用  | obj.m.fn()    | 前面的对象m      |      |     |     |
| call    | fn.call(ctx)  | call的第一个参数  |   立即执行   |  参数列表   |   原函数返回值  |
| apply   | fn.apply(ctx) | apply的第一个参数 |   立即执行   |  参数数组   | 原函数返回值    |
| bind    | fn.bind(ctx)  | bind的第一个参数  |   延迟执行   |  参数列表   |    新绑定函数 |

:::tip
使用建议
优先用 call：参数数量固定时更简洁。

用 apply 处理数组：如合并数组（arr1.push.apply(arr1, arr2)）。

用 bind 固定上下文：解决回调函数中 this 丢失问题（如 React 类组件）。

ES6+ 替代方案：

箭头函数自动继承外层 this（避免 bind）。

扩展运算符（...）替代 apply（func.call(context, ...args)）。

性能注意
在极端性能敏感场景中，call 通常比 apply 稍快（因无需处理数组），bind 因创建新函数会有额外开销。

现代 JS 引擎已高度优化，差异通常可忽略，优先考虑代码可读性。
:::

```javascript
let obj = {
  a:'aaa',
  fn:function () {
    console.log(this.a)
  }
}
let fn = obj.fn();
fn() // 输出全局对象
```

### 核心概念- 原型链
#### 什么是原型链
所有的对象都是通过 `new 函数` 的方式创建的
:::tip
 let u1 = new User();
 所有对象都有隐式原型
![原型链](./assets/images/03%20JS收官/原型链.png)
`Object.prototype.__proto__` 比较特殊，它固定指向null
从上图可以看出， u1的隐式原型形成了一个链条，称之为原型链。当读取对象成员时，会先查看对象自身是否有该成员，如果没有，就依次在其原型链上查找。
:::
